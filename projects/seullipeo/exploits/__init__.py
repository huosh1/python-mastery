#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Gestionnaire des modules d'exploitation Seullipeo
"""

import os
import sys
import importlib
import inspect
from pathlib import Path

# Modules disponibles et leurs métadonnées
AVAILABLE_MODULES = {
    'cron': {
        'description': 'Scanne et exploite les tâches cron vulnérables',
        'author': 'huoshi',
        'risk': 'Medium',
        'available': True,
        'targets': ['Linux', 'Unix']
    },
    'suid': {
        'description': 'Détecte les binaires SUID exploitables',
        'author': 'huoshi', 
        'risk': 'High',
        'available': True,
        'targets': ['Linux', 'Unix']
    },
    'passwd_writable': {
        'description': 'Exploite un fichier /etc/passwd modifiable',
        'author': 'huoshi',
        'risk': 'Critical',
        'available': True,
        'targets': ['Linux', 'Unix']
    },
    'sudo_version': {
        'description': 'Exploite les vulnérabilités sudo connues',
        'author': 'huoshi',
        'risk': 'High',
        'available': True,
        'targets': ['Linux']
    },
    'world_writable': {
        'description': 'Trouve les fichiers et dossiers modifiables par tous',
        'author': 'huoshi',
        'risk': 'Medium',
        'available': True,
        'targets': ['Linux', 'Unix']
    }
}

def get_available_modules():
    """
    Retourne la liste des modules disponibles
    
    Returns:
        dict: Dictionnaire des modules avec leurs métadonnées
    """
    return AVAILABLE_MODULES.copy()

def get_module_path(module_name):
    """
    Retourne le chemin vers un module
    
    Args:
        module_name (str): Nom du module
        
    Returns:
        Path: Chemin vers le fichier du module ou None
    """
    current_dir = Path(__file__).parent
    module_file = current_dir / f"{module_name}.py"
    
    if module_file.exists():
        return module_file
    
    return None

def load_module(module_name):
    """
    Charge dynamiquement un module d'exploitation
    
    Args:
        module_name (str): Nom du module à charger
        
    Returns:
        module: Module chargé ou None en cas d'erreur
    """
    if module_name not in AVAILABLE_MODULES:
        return None
    
    try:
        # Import dynamique
        module_path = f"exploits.{module_name}"
        
        # Supprime le module du cache s'il existe (pour rechargement)
        if module_path in sys.modules:
            del sys.modules[module_path]
        
        module = importlib.import_module(module_path)
        
        # Vérification que le module a une classe Module
        if not hasattr(module, 'Module'):
            raise ImportError(f"Module {module_name} n'a pas de classe 'Module'")
        
        # Vérification que c'est bien une classe
        if not inspect.isclass(module.Module):
            raise ImportError(f"'Module' dans {module_name} n'est pas une classe")
        
        return module
        
    except ImportError as e:
        print(f"Erreur import {module_name}: {e}")
        return None
    except Exception as e:
        print(f"Erreur chargement {module_name}: {e}")
        return None

def list_module_files():
    """
    Liste tous les fichiers de modules présents dans le répertoire
    
    Returns:
        list: Liste des noms de fichiers de modules
    """
    current_dir = Path(__file__).parent
    module_files = []
    
    for file_path in current_dir.glob("*.py"):
        if file_path.name != "__init__.py":
            module_name = file_path.stem
            module_files.append(module_name)
    
    return module_files

def validate_module(module):
    """
    Valide qu'un module respecte l'interface attendue
    
    Args:
        module: Module à valider
        
    Returns:
        tuple: (bool, list) - (valide, liste des erreurs)
    """
    errors = []
    
    if not hasattr(module, 'Module'):
        errors.append("Classe 'Module' manquante")
        return False, errors
    
    module_class = module.Module
    
    # Vérification des méthodes requises
    required_methods = ['scan', 'exploit_all']
    for method in required_methods:
        if not hasattr(module_class, method):
            errors.append(f"Méthode '{method}' manquante")
    
    # Vérification des attributs recommandés
    recommended_attrs = ['description', 'author', 'risk_level']
    for attr in recommended_attrs:
        if not hasattr(module_class, attr):
            errors.append(f"Attribut '{attr}' recommandé manquant")
    
    return len(errors) == 0, errors

def reload_modules():
    """
    Recharge tous les modules (utile pour le développement)
    
    Returns:
        dict: Résultats du rechargement
    """
    results = {
        'success': [],
        'failed': [],
        'total': 0
    }
    
    for module_name in AVAILABLE_MODULES.keys():
        results['total'] += 1
        
        try:
            # Suppression du cache
            module_path = f"exploits.{module_name}"
            if module_path in sys.modules:
                del sys.modules[module_path]
            
            # Rechargement
            module = load_module(module_name)
            if module:
                # Validation
                is_valid, errors = validate_module(module)
                if is_valid:
                    results['success'].append(module_name)
                else:
                    results['failed'].append({
                        'name': module_name,
                        'errors': errors
                    })
            else:
                results['failed'].append({
                    'name': module_name,
                    'errors': ['Impossible de charger le module']
                })
                
        except Exception as e:
            results['failed'].append({
                'name': module_name,
                'errors': [str(e)]
            })
    
    return results

def get_module_info(module_name):
    """
    Retourne les informations détaillées d'un module
    
    Args:
        module_name (str): Nom du module
        
    Returns:
        dict: Informations du module ou None
    """
    if module_name not in AVAILABLE_MODULES:
        return None
    
    info = AVAILABLE_MODULES[module_name].copy()
    
    # Tentative de chargement pour infos dynamiques
    try:
        module = load_module(module_name)
        if module and hasattr(module, 'Module'):
            module_class = module.Module
            
            # Ajout des informations de la classe
            if hasattr(module_class, 'description'):
                info['description'] = module_class.description
            if hasattr(module_class, 'author'):
                info['author'] = module_class.author
            if hasattr(module_class, 'risk_level'):
                info['risk'] = module_class.risk_level
            if hasattr(module_class, 'targets'):
                info['targets'] = module_class.targets
            if hasattr(module_class, 'options'):
                info['options'] = module_class.options
                
    except Exception:
        # Utilise les infos par défaut en cas d'erreur
        pass
    
    return info

# Interface de base pour tous les modules
class BaseModule:
    """
    Classe de base que tous les modules doivent hériter
    """
    
    # Métadonnées du module (à surcharger)
    description = "Module de base"
    author = "huoshi"
    risk_level = "Unknown"
    targets = ["Linux"]
    
    # Options configurables (à surcharger si nécessaire)
    options = {}
    
    def __init__(self):
        """Initialisation du module"""
        self.results = []
        self.last_scan = None
        
    def scan(self):
        """
        Effectue un scan pour détecter les vulnérabilités
        À implémenter dans chaque module
        
        Returns:
            list: Liste des vulnérabilités trouvées
        """
        raise NotImplementedError("Méthode scan() doit être implémentée")
    
    def exploit_all(self):
        """
        Exploite toutes les vulnérabilités trouvées
        À implémenter dans chaque module
        
        Returns:
            list: Résultats des exploitations
        """
        raise NotImplementedError("Méthode exploit_all() doit être implémentée")
    
    def exploit_single(self, vulnerability):
        """
        Exploite une vulnérabilité spécifique
        Implémentation par défaut, peut être surchargée
        
        Args:
            vulnerability (dict): Vulnérabilité à exploiter
            
        Returns:
            dict: Résultat de l'exploitation
        """
        return {
            'success': False,
            'error': 'exploit_single() non implémenté pour ce module'
        }
    
    def cleanup(self):
        """
        Nettoie les ressources utilisées par le module
        Implémentation optionnelle
        """
        pass
    
    def get_info(self):
        """
        Retourne les informations du module
        
        Returns:
            dict: Informations du module
        """
        return {
            'description': self.description,
            'author': self.author,
            'risk_level': self.risk_level,
            'targets': self.targets,
            'options': self.options
        }